<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Skincare Scatterplot — Category + Skin Type Filters</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; background: #f6f7fb; margin: 24px; }
    h1 { text-align: center; margin: 0 0 8px; }
    .row { display: flex; gap: 16px; align-items: center; margin-bottom: 12px; }
    label { font-size: 14px; color: #333; }
    select { padding: 6px 10px; border-radius: 8px; border: 1px solid #ccc; background: #fff; }
    svg { background: #fff; border: 1px solid #ddd; border-radius: 8px; }
    .axis path, .axis line { stroke: #bbb; }
    .legend { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .legend .item { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; color: #444; }
    .legend .swatch { width: 12px; height: 12px; border-radius: 2px; border: 1px solid #999; }
    .tooltip {
      position: fixed; pointer-events: none; z-index: 10;
      background: rgba(20,24,40,.95); color: #f2f4ff; padding: 8px 10px;
      border: 1px solid #404868; border-radius: 8px; font-size: 12px;
      transform: translate(10px, -10px); opacity: 0; transition: opacity .1s;
      max-width: 320px; line-height: 1.3;
    }
  </style>
</head>
<body>

      <!-- Page Title -->
  <h1>Project 3 checkpoint</h1>
  <p style="text-align:center; margin-top:4px; color:#555;">
Interactive visualizations exploring skincare data
</p>






  

    <h2 style="margin-bottom: 20px;">Price vs Rating</h2>
    <p style="margin-top:0; color:#666; font-size:14px;">
Explore how product prices and customer ratings vary across different categories and skin types.
</p>
    <div class="row">
    <label>Category:
      <select id="categorySelect"><option value="__all__">All</option></select>
    </label>
    <label>Skin Type:
      <select id="skinSelect">
        <option value="__all__">All</option>
        <option value="Dry">Dry</option>
        <option value="Normal">Normal</option>
        <option value="Oily">Oily</option>
        <option value="Combination">Combination</option>
        <option value="Sensitive">Sensitive</option>
      </select>
    </label>
  </div>

  <svg id="chart" width="860" height="540"></svg>
  <div class="legend" id="legend"></div>
  <div class="tooltip" id="tooltip"></div>

  <script>
    const width = 860, height = 540, margin = {top: 30, right: 20, bottom: 56, left: 64};
    const svg = d3.select("#chart").attr("width", width).attr("height", height);
    const g = svg.append("g");

    const xAxisG = g.append("g").attr("transform", `translate(0,${height - margin.bottom})`).attr("class","axis");
    const yAxisG = g.append("g").attr("transform", `translate(${margin.left},0)`).attr("class","axis");
    const pointsG = g.append("g").attr("class","points");

    const tooltip = d3.select("#tooltip");
    const categorySelect = d3.select("#categorySelect");
    const skinSelect = d3.select("#skinSelect");
    const legend = d3.select("#legend");

    const x = d3.scaleLinear().range([margin.left, width - margin.right]);
    const y = d3.scaleLinear().range([height - margin.bottom, margin.top]).domain([0,5]); // ratings 0–5
    const color = d3.scaleOrdinal(d3.schemeTableau10);

    const to01 = v => {
      if (v === undefined || v === null) return 0;
      const s = String(v).trim().toLowerCase();
      return (s === "1" || s === "true" || s === "yes" || s === "y") ? 1 : (+v === 1 ? 1 : 0);
    };

    d3.csv("data/cosmetic_p.csv").then(rows => {
      // parse
      const data = rows.map(d => ({
        brand: d.brand || d.Brand || "",
        name: d.name || d.Product || d.product_name || "",
        cat: d.Label || d.category || "Uncategorized",
        price: +d.price,
        rank: +d.rank,   // rating
        Dry: to01(d.Dry),
        Normal: to01(d.Normal),
        Oily: to01(d.Oily),
        Combination: to01(d.Combination),
        Sensitive: to01(d.Sensitive)
      })).filter(d => isFinite(d.price) && isFinite(d.rank));

      // scales
      x.domain(d3.extent(data, d => d.price)).nice();

      // axes
      const xAxis = d3.axisBottom(x).ticks(8).tickFormat(d3.format("$,.0f"));
      const yAxis = d3.axisLeft(y).ticks(6);
      xAxisG.call(xAxis)
            .append("text")
            .attr("x", width - margin.right)
            .attr("y", 40).attr("fill","#222")
            .attr("text-anchor","end").attr("font-weight","600")
            .text("Price ($)");
      yAxisG.call(yAxis)
            .append("text")
            .attr("x", 0).attr("y", margin.top - 12)
            .attr("fill","#222").attr("text-anchor","start").attr("font-weight","600")
            .text("Rating (0–5)");

      // categories (legend + dropdown)
      const cats = Array.from(new Set(data.map(d => d.cat))).sort();
      color.domain(cats);
      categorySelect.selectAll("option.cat")
        .data(cats)
        .join("option")
        .attr("class","cat")
        .attr("value", d => d)
        .text(d => d);
      legend.selectAll("span.item")
        .data(cats)
        .join("span")
        .attr("class","item")
        .html(d => `<span class="swatch" style="background:${color(d)}"></span> ${d}`);

      function render() {
        const selectedCat = categorySelect.node().value;
        const selectedSkin = skinSelect.node().value;

        let shown = selectedCat === "__all__" ? data : data.filter(d => d.cat === selectedCat);
        if (selectedSkin !== "__all__") {
          shown = shown.filter(d => d[selectedSkin] === 1);
        }

        const circles = pointsG.selectAll("circle").data(shown, d => d.brand + "|" + d.name + "|" + d.price);

        circles.exit()
          .transition().duration(150)
          .attr("r", 0).remove();

        circles.join(
          enter => enter.append("circle")
            .attr("cx", d => x(d.price))
            .attr("cy", d => y(d.rank))
            .attr("r", 0)
            .attr("fill", d => color(d.cat))
            .attr("opacity", 0.8)
            .on("pointerenter", (e, d) => {
              tooltip.html(`
                <div style="font-weight:600">${(d.brand || "").trim()} ${(d.name ? "— " + d.name : "")}</div>
                <div>${d.cat}</div>
                <div><b>Price:</b> ${d3.format("$,.2f")(d.price)} &nbsp; • &nbsp; <b>Rating:</b> ${d.rank.toFixed(2)}</div>
              `).style("opacity", 1);
            })
            .on("pointermove", (e) => {
              tooltip.style("left", (e.clientX + 12) + "px")
                     .style("top",  (e.clientY - 12) + "px");
            })
            .on("pointerleave", () => tooltip.style("opacity", 0))
            .transition().duration(300)
            .attr("r", 4.5),
          update => update
            .transition().duration(250)
            .attr("cx", d => x(d.price))
            .attr("cy", d => y(d.rank))
            .attr("fill", d => color(d.cat))
        );
      }

      categorySelect.on("change", render);
      skinSelect.on("change", render);
      render();
    });
  </script>








<!-- ===== Ingredient Popularity (Grouped Bars) ===== -->
  <h2 style="margin-top:40px;">Ingredient Popularity</h2>
  <p style="margin-top:0; color:#666; font-size:14px;">
Analyze the relationship between ingredient usage and product count/ratings.
</p>

<div class="row">
      </label>
      <label>
    <input id="ingFilter" type="text" placeholder="type to filter Ingredients" style="padding:6px 10px; border-radius:8px; border:1px solid #ccc; min-width:220px;">
  </label>
  <label>Metric:
    <select id="gbMetric">
      <option value="count">Count of products</option>
      <option value="avg">Average rating</option>
    </select>
  </label>
  <label>X-Axis:
    <select id="gbXAxis">
      <option value="category">Category</option>
      <option value="priceTier">Price Tiers</option>
    </select>
</div>

<div class="row" style="margin-top:10px;">
    <label>
    <select id="ingMulti" multiple size="8" style="width: 243px;"></select>
  </label>
</div>

<svg id="ingBars" width="860" height="540"></svg>
<div class="tooltip" id="ingBarsTip"></div>

<script>
(() => {
  const width = 860, height = 540, m = {top: 30, right: 20, bottom: 80, left: 80};
  const svg = d3.select("#ingBars").attr("width", width).attr("height", height);
  const g = svg.append("g");

  const x0 = d3.scaleBand().paddingInner(0.25).range([m.left, width - m.right]); // buckets
  const x1 = d3.scaleBand().padding(0.15); // ingredients within bucket
  const y  = d3.scaleLinear().range([height - m.bottom, m.top]);

  const xAxisG = g.append("g").attr("transform", `translate(0,${height - m.bottom})`).attr("class","axis");
  const yAxisG = g.append("g").attr("transform", `translate(${m.left},0)`).attr("class","axis");
  const barsG  = g.append("g");
  const legendG= g.append("g").attr("transform", `translate(${m.left}, ${m.top - 10})`);
  const tip = d3.select("#ingBarsTip");

  const color = d3.scaleOrdinal(d3.schemeTableau10);

  // controls
  const filterInput = d3.select("#ingFilter");
  const ingSelect   = d3.select("#ingMulti");
  const metricSel   = d3.select("#gbMetric");
  const xSel        = d3.select("#gbXAxis");

    // Helpers
function titleCase(s){ return s.replace(/\b[a-z]/g, c => c.toUpperCase()); }

// Strict CSV-style ingredient parser: split ONLY on commas.
function parseIngredients(s){
  if (s == null) return [];
  return String(s)
    .split(",")                 // ONLY commas
    .map(t => t.trim())
    .filter(t => t.length > 0)
    .map(t => t.toLowerCase());
}


  function quantileTiers(values){
    const v = values.filter(d => isFinite(d)).sort(d3.ascending);
    return { q33: d3.quantile(v, 1/3), q66: d3.quantile(v, 2/3) };
  }
  function tierForPrice(p, t){ return p<=t.q33 ? "Low" : (p<=t.q66 ? "Mid" : "High"); }

  // state
  let DATA = [];
  let CATEGORIES = [];
  let TIERS = null;
  const PRICE_TIER = ["Low","Mid","High"];
  let TOP_ING = []; // [{name, n}]
  let currentOptions = []; // filtered list for select

  // Build top-N ingredient list
  function computeTopIngredients(data, N=200){
    const map = new Map();
    for(const d of data){
      const uniq = new Set(d.ingredients);
      for(const ing of uniq){
        map.set(ing, (map.get(ing)||0) + 1);
      }
    }
    return Array.from(map.entries())
      .map(([name, n]) => ({name, n}))
      .sort((a,b) => d3.descending(a.n, b.n))
      .slice(0,N);
  }

  function populateSelect(list){
    currentOptions = list;
    const selected = new Set(Array.from(ingSelect.node().selectedOptions).map(o => o.value));
    const opts = ingSelect.selectAll("option").data(list, d => d.name);
    opts.exit().remove();
    opts.enter().append("option")
      .merge(opts)
      .attr("value", d => d.name)
      .property("selected", d => selected.has(d.name))
      .text(d => `${titleCase(d.name)}  (${d.n})`);
  }

  function filterOptions(){
    const q = filterInput.node().value.trim().toLowerCase();
    const f = q ? TOP_ING.filter(d => d.name.includes(q)) : TOP_ING;
    populateSelect(f);
  }

  function selectedIngredients(){
    return Array.from(ingSelect.node().selectedOptions).map(o => o.value);
  }

  function aggregate(ingredients, mode){
    // mode: 'category' | 'priceTier'
    const metric = metricSel.node().value; // 'count' | 'avg'
    const buckets = (mode === "category") ? CATEGORIES : PRICE_TIER;

    // For each ingredient, compute per-bucket stats
    const series = ingredients.map(ing => {
      const vals = buckets.map(b => {
        const subset = DATA.filter(d => {
          const inBucket = (mode === "category") ? (d.cat === b) : (tierForPrice(d.price, TIERS) === b);
          return inBucket && d.ingredientsSet.has(ing);
        });
        const n = subset.length;
        const avg = n ? d3.mean(subset, d => d.rank) : NaN;
        return { bucket: b, n, avg };
      });
      return { ingredient: ing, values: vals };
    });

    // y-domain
    if (metric === "count") {
      const maxN = d3.max(series.flatMap(s => s.values), d => d.n) || 1;
      y.domain([0, maxN]).nice();
    } else {
      y.domain([0, 5]); // ratings
    }

    x0.domain(buckets);
    x1.domain(ingredients).range([0, x0.bandwidth()]);

    // axes + titles
    xAxisG.call(d3.axisBottom(x0)).selectAll("text").style("font-size","12px").attr("transform","translate(0,0)");
    yAxisG.call(d3.axisLeft(y).ticks(6));

    xAxisG.selectAll("text.axis-title").remove();
    yAxisG.selectAll("text.axis-title").remove();
    xAxisG.append("text").attr("class","axis-title")
      .attr("x", width - m.right).attr("y", 48).attr("fill","#222").attr("text-anchor","end").attr("font-weight","600")
      .text(mode === "category" ? "Category" : "Price Tier");
    yAxisG.append("text").attr("class","axis-title")
      .attr("x", 0).attr("y", m.top - 12).attr("fill","#222").attr("text-anchor","start").attr("font-weight","600")
      .text(metric === "count" ? "Products with ingredient" : "Average rating (0–5)");

    // flat rows: one entry per (bucket, ingredient)
    const flat = [];
    for (const s of series) {
      for (const v of s.values) {
        flat.push({ ingredient: s.ingredient, bucket: v.bucket, n: v.n, avg: v.avg });
      }
    }

    // draw bars
    const bars = barsG.selectAll("rect.bar").data(flat, d => d.bucket + "|" + d.ingredient);
    bars.exit().transition().duration(200).attr("y", y(0)).attr("height", 0).remove();

    bars.join(
      enter => enter.append("rect")
        .attr("class","bar")
        .attr("x", d => x0(d.bucket) + x1(d.ingredient))
        .attr("y", d => y( metric === "count" ? d.n : (isFinite(d.avg) ? d.avg : 0) ))
        .attr("width", x1.bandwidth())
        .attr("height", d => (height - m.bottom) - y( metric === "count" ? d.n : (isFinite(d.avg) ? d.avg : 0) ))
        .attr("fill", d => color(d.ingredient))
        .on("pointerenter", (e,d) => {
          const v = (metric === "count")
            ? `Products: <b>${d.n}</b>`
            : `Avg rating: <b>${isFinite(d.avg) ? d.avg.toFixed(2) : "—"}</b> (n=${d.n})`;
          tip.html(`${titleCase(d.ingredient)}<br>${mode === "category" ? "Category" : "Tier"}: ${d.bucket}<br>${v}`)
             .style("opacity", 1);
        })
        .on("pointermove", (e) => tip.style("left", (e.clientX + 12) + "px").style("top", (e.clientY - 12) + "px"))
        .on("pointerleave", () => tip.style("opacity", 0)),
      update => update
        .transition().duration(250)
        .attr("x", d => x0(d.bucket) + x1(d.ingredient))
        .attr("y", d => y( metric === "count" ? d.n : (isFinite(d.avg) ? d.avg : 0) ))
        .attr("width", x1.bandwidth())
        .attr("height", d => (height - m.bottom) - y( metric === "count" ? d.n : (isFinite(d.avg) ? d.avg : 0) ))
        .attr("fill", d => color(d.ingredient))
    );

    // legend chips (click to deselect)
    const picks = legendG.selectAll("g.pill").data(ingredients, d => d);
    picks.exit().remove();
    const pillEnter = picks.enter().append("g").attr("class","pill").style("cursor","pointer")
      .on("click", (_,name) => {
        // unselect in <select>
        const options = Array.from(ingSelect.node().options);
        options.forEach(o => { if (o.value === name) o.selected = false; });
        render();
      });
    pillEnter.append("rect").attr("rx",10).attr("ry",10).attr("height",18).attr("fill","#eef3ff").attr("stroke","#cdd9ff");
    pillEnter.append("circle").attr("r",5).attr("cy",9);
    pillEnter.append("text").attr("y",13).attr("font-size",12).attr("fill","#333");

    const merged = pillEnter.merge(picks);
    merged.select("circle").attr("cx", 9).attr("fill", d => color(d));
    merged.select("text").text(d => " " + titleCase(d)).attr("x", 18);

    let xCursor = 0;
    merged.each(function(d){
      const t = d3.select(this).select("text");
      const w = t.node().getComputedTextLength() + 28;
      d3.select(this).attr("transform", `translate(${m.left + xCursor}, ${m.top - 24})`);
      d3.select(this).select("rect").attr("width", w);
      xCursor += w + 8;
    });
  }

  function render(){
    const chosen = selectedIngredients();
    const mode = xSel.node().value; // 'category' | 'priceTier'
    barsG.selectAll("*").interrupt(); // smooth updates
    if (chosen.length === 0) {
      // Draw axes only
      x0.domain(mode === "category" ? CATEGORIES : PRICE_TIER);
      xAxisG.call(d3.axisBottom(x0));
      y.domain([0,5]).nice();
      yAxisG.call(d3.axisLeft(y));
      barsG.selectAll("*").remove();
      legendG.selectAll("*").remove();
      return;
    }
    aggregate(chosen, mode);
  }

  // init
  d3.csv("data/cosmetic_p.csv").then(rows => {
    const raw = rows.map(d => ({
      cat: d.Label || d.category || "Uncategorized",
      price: +d.price,
      rank: +d.rank,
      ingredients: parseIngredients(d.ingredients || d.Ingredients || d.INGREDIENTS || "")
    })).filter(d => isFinite(d.rank) && isFinite(d.price));

    raw.forEach(d => d.ingredientsSet = new Set(d.ingredients));
    DATA = raw;
    CATEGORIES = Array.from(new Set(DATA.map(d => d.cat))).sort();
    TIERS = quantileTiers(DATA.map(d => d.price));
    TOP_ING = computeTopIngredients(DATA, 200);
    populateSelect(TOP_ING);

    // events
    filterInput.on("input", () => filterOptions());
    ingSelect.on("change", render);
    metricSel.on("change", render);
    xSel.on("change", render);

    // seed with two common ingredients (selected)
    const seeds = TOP_ING.slice(0,2).map(d => d.name);
    Array.from(ingSelect.node().options).forEach(o => { if (seeds.includes(o.value)) o.selected = true; });
    render();
  });
})();
</script>









  <h2 style="margin-top:40px;">Ingredients vs Rating</h2>
  <p style="margin-top:0; color:#666; font-size:14px;">
Analyze which ingredients are most common in high-rated skincare products.
</p>
<div class="row">
  <label>Category:
    <select id="ingCategory"><option value="__all__">All</option></select>
  </label>
  <label>Min # of products that include ingredient:
    <input type="range" id="minCount" min="5" max="100" value="20" />
    <span id="minCountVal">20</span>
  </label>
</div>
<svg id="ingChart" width="860" height="540"></svg>
<div class="tooltip" id="tooltip2"></div>

<script>
(() => {
  const width = 860, height = 540, m = {top: 30, right: 20, bottom: 56, left: 200};
  const svg = d3.select("#ingChart").attr("width", width).attr("height", height);
  const g = svg.append("g");

  // axes groups
  const xAxisG = g.append("g").attr("transform", `translate(0,${height - m.bottom})`).attr("class","axis");
  const yAxisG = g.append("g").attr("transform", `translate(${m.left},0)`).attr("class","axis");

  const x = d3.scaleLinear().domain([0,5]).range([m.left, width - m.right]); // ratings 0–5
  const y = d3.scaleBand().padding(0.15).range([m.top, height - m.bottom]);

  const tooltip = d3.select("#tooltip2");
  const catSel = d3.select("#ingCategory");
  const minSlider = d3.select("#minCount");
  const minVal = d3.select("#minCountVal");

    // Helpers
function titleCase(s){ return s.replace(/\b[a-z]/g, c => c.toUpperCase()); }

// Strict CSV-style ingredient parser: split ONLY on commas.
function parseIngredients(s){
  if (s == null) return [];
  return String(s)
    .split(",")                 // ONLY commas
    .map(t => t.trim())
    .filter(t => t.length > 0)
    .map(t => t.toLowerCase());
}


  d3.csv("data/cosmetic_p.csv").then(rows => {
    const data = rows.map(d => ({
      brand: d.brand || d.Brand || "",
      name: d.name || d.Product || d.product_name || "",
      cat:  d.Label || d.category || "Uncategorized",
      rank: +d.rank,
      ingredients: parseIngredients(d.ingredients || d.Ingredients || d.INGREDIENTS || "")
    })).filter(d => isFinite(d.rank));

    // populate category select (independent)
    const cats = Array.from(new Set(data.map(d => d.cat))).sort();
    catSel.selectAll("option.cat")
      .data(cats).join("option")
      .attr("class","cat")
      .attr("value", d => d).text(d => d);

    function computeStats(){
      const selectedCat = catSel.node().value;
      const base = selectedCat === "__all__" ? data : data.filter(d => d.cat === selectedCat);

      // ingredient -> {n, sum, examples[]}
      const map = new Map();
      for(const prod of base){
        // Use a Set so a product only counts once per ingredient
        const uniq = new Set(prod.ingredients);
        for(const ing of uniq){
          if(!map.has(ing)) map.set(ing, {ing, n:0, sum:0, examples:[]});
          const rec = map.get(ing);
          rec.n += 1;
          rec.sum += prod.rank;
          if(rec.examples.length < 2) rec.examples.push(prod.brand || prod.name);
        }
      }

      let arr = Array.from(map.values());
      const minN = +minSlider.node().value;
      arr = arr.filter(d => d.n >= minN);
      arr.forEach(d => d.avg = d.sum / d.n);

      // Top 20 by average rating
      arr.sort((a,b) => d3.descending(a.avg, b.avg));
      return arr.slice(0, 20);
    }

    function render(){
      minVal.text(minSlider.node().value);
      const stats = computeStats();

      y.domain(stats.map(d => d.ing));

      xAxisG.call(d3.axisBottom(x).ticks(6));
      yAxisG.call(d3.axisLeft(y).tickSize(0))
            .selectAll("text").style("font-size","12px");

      // Bars
      const bars = g.selectAll("rect.bar").data(stats, d => d.ing);

      bars.exit()
        .transition().duration(200)
        .attr("width", 0)
        .remove();

      bars.join(
        enter => enter.append("rect")
          .attr("class","bar")
          .attr("x", x(0))
          .attr("y", d => y(d.ing))
          .attr("height", y.bandwidth())
          .attr("width", 0)
          .attr("fill", "#4c78a8")
          .on("pointerenter", (e, d) => {
            tooltip.html(
              `<b>${d.ing.replace(/\\b[a-z]/g,c=>c.toUpperCase())}</b><br>` +
              `Avg rating: ${d.avg.toFixed(2)}<br>` +
              `Products: ${d.n}<br>` +
              (d.examples.length ? `Examples: ${d.examples.join(", ")}` : "")
            ).style("opacity", 1);
          })
          .on("pointermove", (e) => {
            tooltip.style("left", (e.clientX + 12) + "px")
                   .style("top",  (e.clientY - 12) + "px");
          })
          .on("pointerleave", () => tooltip.style("opacity", 0))
          .transition().duration(300)
          .attr("width", d => x(d.avg) - x(0)),
        update => update
          .transition().duration(250)
          .attr("y", d => y(d.ing))
          .attr("height", y.bandwidth())
          .attr("width", d => x(d.avg) - x(0))
      );

      // Value labels
      const labels = g.selectAll("text.value").data(stats, d => d.ing);
      labels.exit().remove();
      labels.join(
        enter => enter.append("text")
          .attr("class","value")
          .attr("x", d => x(d.avg) + 6)
          .attr("y", d => y(d.ing) + y.bandwidth()/2 + 4)
          .attr("fill", "#333")
          .text(d => d.avg.toFixed(2)),
        update => update
          .transition().duration(250)
          .attr("x", d => x(d.avg) + 6)
          .attr("y", d => y(d.ing) + y.bandwidth()/2 + 4)
          .text(d => d.avg.toFixed(2))
      );
    }

    catSel.on("change", render);
    minSlider.on("input", render);
    render();
  });
})();
</script>




<!-- ===== Brand Ranking Chart (matched spacing) ===== -->
  <h2 style="margin-top:40px;">Top 15 Brands by Average Rating</h2>
  <p style="margin-top:0; color:#666; font-size:14px;">
Analyze which brands are most highly rated for skincare products.
</p>

<div class="row">
  <label>Category:
    <select id="brandCat"><option value="__all__">All</option></select>
  </label>
  <label>Skin Type:
    <select id="brandSkin">
      <option value="__all__">All</option>
      <option value="Dry">Dry</option>
      <option value="Normal">Normal</option>
      <option value="Oily">Oily</option>
      <option value="Combination">Combination</option>
      <option value="Sensitive">Sensitive</option>
    </select>
  </label>
</div>
<svg id="brandChart" width="860" height="540"></svg>
<div class="tooltip" id="tooltipBrand"></div>

<script>
(() => {
  // Match the other charts' dimensions, with a bit of extra right margin so labels don't clip
  const width = 860, height = 540, m = { top: 30, right: 60, bottom: 56, left: 180 };
  const svg = d3.select("#brandChart").attr("width", width).attr("height", height);
  const g = svg.append("g");

  const xAxisG = g.append("g")
    .attr("transform", `translate(0,${height - m.bottom})`)
    .attr("class","axis");
  const yAxisG = g.append("g")
    .attr("transform", `translate(${m.left},0)`)
    .attr("class","axis");

  const x = d3.scaleLinear().domain([0,5]).range([m.left, width - m.right]); // ratings 0–5
  const y = d3.scaleBand().padding(0.15).range([m.top, height - m.bottom]);

  const catSel  = d3.select("#brandCat");
  const skinSel = d3.select("#brandSkin");
  const tip     = d3.select("#tooltipBrand");
  const dollar  = d3.format("$,.2f");

  const to01 = v => {
    if (v == null) return 0;
    const s = String(v).trim().toLowerCase();
    return (s === "1" || s === "true" || s === "yes" || s === "y") ? 1 : (+v === 1 ? 1 : 0);
  };

  d3.csv("data/cosmetic_p.csv").then(rows => {
    const data = rows.map(d => ({
      brand: (d.brand || d.Brand || "").trim() || "Unknown",
      name:  d.name || d.Product || d.product_name || "",
      cat:   d.Label || d.category || "Uncategorized",
      price: +d.price,
      rank:  +d.rank,
      Dry: to01(d.Dry), Normal: to01(d.Normal), Oily: to01(d.Oily),
      Combination: to01(d.Combination), Sensitive: to01(d.Sensitive)
    })).filter(d => isFinite(d.rank));

    // Populate category dropdown (independent)
    const cats = Array.from(new Set(data.map(d => d.cat))).sort();
    catSel.selectAll("option.cat")
      .data(cats).join("option")
      .attr("class","cat").attr("value", d => d).text(d => d);

    function computeStats(){
      const c = catSel.node().value;
      const s = skinSel.node().value;

      let base = (c === "__all__") ? data : data.filter(d => d.cat === c);
      if (s !== "__all__") base = base.filter(d => d[s] === 1);

      const map = new Map();
      for (const p of base){
        if (!map.has(p.brand)) map.set(p.brand, { brand: p.brand, n:0, sumR:0, sumP:0 });
        const b = map.get(p.brand);
        b.n    += 1;
        b.sumR += p.rank;
        if (isFinite(p.price)) b.sumP += p.price;
      }

      let arr = Array.from(map.values());
      arr.forEach(d => {
        d.avgR = d.sumR / d.n;
        d.avgP = d.n ? d.sumP / d.n : 0;
      });

      // Sort by avg rating desc, then by product count desc
      arr.sort((a,b) => d3.descending(a.avgR, b.avgR) || d3.descending(a.n, b.n));
      return arr.slice(0, 15);
    }

    function render(){
      const stats = computeStats();

      y.domain(stats.map(d => d.brand));
      xAxisG.call(d3.axisBottom(x).ticks(6));
      yAxisG.call(d3.axisLeft(y).tickSize(0))
            .selectAll("text").style("font-size","12px");

      // Bars
      const bars = g.selectAll("rect.bar").data(stats, d => d.brand);

      bars.exit().transition().duration(200).attr("width", 0).remove();

      bars.join(
        enter => enter.append("rect")
          .attr("class","bar")
          .attr("x", x(0))
          .attr("y", d => y(d.brand))
          .attr("height", y.bandwidth())
          .attr("width", 0)
          .attr("fill", "#6aaed6")
          .on("pointerenter", (e, d) => {
            tip.html(
              `<b>${d.brand}</b><br>` +
              `Avg rating: ${d.avgR.toFixed(2)}<br>` +
              `Products: ${d.n}<br>` +
              `Avg price: ${dollar(d.avgP)}`
            ).style("opacity", 1);
          })
          .on("pointermove", (e) => {
            tip.style("left", (e.clientX + 12) + "px")
               .style("top",  (e.clientY - 12) + "px");
          })
          .on("pointerleave", () => tip.style("opacity", 0))
          .transition().duration(300)
          .attr("width", d => x(d.avgR) - x(0)),
        update => update
          .transition().duration(250)
          .attr("y", d => y(d.brand))
          .attr("height", y.bandwidth())
          .attr("width", d => x(d.avgR) - x(0))
      );

      // Value labels (shifted inside the right margin so they don't clip)
      const labels = g.selectAll("text.value").data(stats, d => d.brand);
      labels.exit().remove();
      labels.join(
        enter => enter.append("text")
          .attr("class","value")
          .attr("x", d => Math.min(x(d.avgR) + 6, width - m.right + 4))
          .attr("y", d => y(d.brand) + y.bandwidth()/2 + 4)
          .attr("fill", "#333")
          .text(d => d.avgR.toFixed(2)),
        update => update
          .transition().duration(250)
          .attr("x", d => Math.min(x(d.avgR) + 6, width - m.right + 4))
          .attr("y", d => y(d.brand) + y.bandwidth()/2 + 4)
          .text(d => d.avgR.toFixed(2))
      );
    }

    catSel.on("change", render);
    skinSel.on("change", render);
    render();
  });
})();
</script>






<!-- ===== Heatmap Explorer: Price × Rating ===== -->
  <h2 style="margin-top:40px;">Price x Rating Heatmap</h2>
  <p style="margin-top:0; color:#666; font-size:14px;">
Visualize the relationship between product price and customer rating.
</p>

<div class="row">
  <label>Category:
    <select id="hmCategory"><option value="__all__">All</option></select>
  </label>
  <label>Skin Type:
    <select id="hmSkin">
      <option value="__all__">All</option>
      <option value="Dry">Dry</option>
      <option value="Normal">Normal</option>
      <option value="Oily">Oily</option>
      <option value="Combination">Combination</option>
      <option value="Sensitive">Sensitive</option>
    </select>
  </label>
  <label>Metric:
    <select id="hmMetric">
      <option value="count">Count</option>
      <option value="avg">Avg Rating</option>
    </select>
  </label>
  <label>Bin size:
    <input id="hmBins" type="range" min="8" max="40" value="20">
    <span id="hmBinsVal">20</span>
  </label>
</div>

<svg id="heatmap" width="860" height="540"></svg>
<div class="tooltip" id="hmTooltip"></div>

<script>
(() => {
  const width = 860, height = 540, m = {top: 30, right: 20, bottom: 56, left: 64};
  const svg = d3.select("#heatmap").attr("width", width).attr("height", height);
  const g = svg.append("g");

  const xAxisG = g.append("g").attr("transform", `translate(0,${height - m.bottom})`).attr("class","axis");
  const yAxisG = g.append("g").attr("transform", `translate(${m.left},0)`).attr("class","axis");
  const cellsG = g.append("g").attr("class","cells");

  const x = d3.scaleLinear().range([m.left, width - m.right]);
  const y = d3.scaleLinear().range([height - m.bottom, m.top]).domain([0,5]); // rating 0–5

  const catSel  = d3.select("#hmCategory");
  const skinSel = d3.select("#hmSkin");
  const metricSel = d3.select("#hmMetric");
  const binSlider = d3.select("#hmBins");
  const binVal = d3.select("#hmBinsVal");
  const tip = d3.select("#hmTooltip");

  const to01 = v => {
    if (v == null) return 0;
    const s = String(v).trim().toLowerCase();
    return (s === "1" || s === "true" || s === "yes" || s === "y") ? 1 : (+v === 1 ? 1 : 0);
  };

  d3.csv("data/cosmetic_p.csv").then(rows => {
    const data = rows.map(d => ({
      cat:   d.Label || d.category || "Uncategorized",
      price: +d.price,
      rank:  +d.rank,
      Dry: to01(d.Dry), Normal: to01(d.Normal), Oily: to01(d.Oily),
      Combination: to01(d.Combination), Sensitive: to01(d.Sensitive)
    })).filter(d => isFinite(d.price) && isFinite(d.rank));

    // scales
    x.domain(d3.extent(data, d => d.price)).nice();

    // axes with labels
    xAxisG.call(d3.axisBottom(x).ticks(8).tickFormat(d3.format("$,.0f")))
      .append("text")
      .attr("x", width - m.right)
      .attr("y", 40).attr("fill","#222").attr("text-anchor","end").attr("font-weight","600")
      .text("Price ($)");
    yAxisG.call(d3.axisLeft(y).ticks(6))
      .append("text")
      .attr("x", 0).attr("y", m.top - 12)
      .attr("fill","#222").attr("text-anchor","start").attr("font-weight","600")
      .text("Rating (0–5)");

    // categories
    const cats = Array.from(new Set(data.map(d => d.cat))).sort();
    catSel.selectAll("option.cat")
      .data(cats).join("option")
      .attr("class","cat").attr("value", d => d).text(d => d);

    // color scales for two metrics
    const colorCount = d3.scaleSequential().interpolator(d3.interpolateBlues); // darker = more products
    const colorAvg   = d3.scaleSequential().domain([3, 5]).interpolator(d3.interpolateYlGn); // greener = higher avg rating

    function binData() {
      const binsX = +binSlider.node().value; // number of bins across X
      const binsY = Math.round(binsX * 0.5); // keep rectangular-ish cells

      const xThresh = d3.range(binsX + 1).map(t => x.invert(m.left + t * ( (width - m.left - m.right) / binsX )));
      const yThresh = d3.range(binsY + 1).map(t => y.invert( (height - m.bottom) - t * ( (height - m.bottom - m.top) / binsY ) ));

      const selCat  = catSel.node().value;
      const selSkin = skinSel.node().value;

      let base = (selCat === "__all__") ? data : data.filter(d => d.cat === selCat);
      if (selSkin !== "__all__") base = base.filter(d => d[selSkin] === 1);

      // initialize empty grid
      const grid = [];
      for (let j = 0; j < binsY; j++) {
        for (let i = 0; i < binsX; i++) {
          grid.push({i, j, n:0, sum:0});
        }
      }

      // put each product into a cell
      const xMin = x.domain()[0], xMax = x.domain()[1];
      const yMin = 0, yMax = 5;
      const ix = v => Math.min(binsX - 1, Math.max(0, Math.floor( (v - xMin) / (xMax - xMin) * binsX )));
      const iy = v => Math.min(binsY - 1, Math.max(0, Math.floor( (v - yMin) / (yMax - yMin) * binsY )));

      for (const p of base) {
        const ci = ix(p.price);
        const cj = iy(p.rank);
        const c  = grid[cj * binsX + ci];
        c.n += 1;
        c.sum += p.rank;
      }

      // domains for color
      const maxN = d3.max(grid, d => d.n) || 1;
      colorCount.domain([0, maxN]);      // automatically adapts to density
      colorAvg.domain([3, 5]);           // fixed, highlights high-rating pockets

      return { grid, binsX, binsY, maxN };
    }

    function render() {
      binVal.text(binSlider.node().value);
      const metric = metricSel.node().value; // 'count' | 'avg'
      const { grid, binsX, binsY, maxN } = binData();

      const cellW = (width - m.left - m.right) / binsX;
      const cellH = (height - m.bottom - m.top) / binsY;

      const rects = cellsG.selectAll("rect.cell").data(grid, d => d.i + "-" + d.j);

      rects.exit().remove();

      rects.join(
        enter => enter.append("rect")
          .attr("class", "cell")
          .attr("x", d => m.left + d.i * cellW)
          .attr("y", d => m.top + (binsY - 1 - d.j) * cellH) // invert y so higher rating is higher
          .attr("width", cellW + 0.5)
          .attr("height", cellH + 0.5)
          .attr("fill", d => {
            if (d.n === 0) return "#f3f4f7";
            return metric === "count" ? colorCount(d.n) : colorAvg(d.sum / d.n);
          })
          .on("pointerenter", (e, d) => {
            if (d.n === 0) return;
            const avg = (d.sum / d.n).toFixed(2);
            tip.html(metric === "count"
              ? `<b>${d.n}</b> products in this bin`
              : `Avg rating: <b>${avg}</b><br>Products: ${d.n}`
            ).style("opacity", 1);
          })
          .on("pointermove", (e) => {
            tip.style("left", (e.clientX + 12) + "px")
               .style("top",  (e.clientY - 12) + "px");
          })
          .on("pointerleave", () => tip.style("opacity", 0)),
        update => update
          .attr("x", d => m.left + d.i * cellW)
          .attr("y", d => m.top + (binsY - 1 - d.j) * cellH)
          .attr("width", cellW + 0.5)
          .attr("height", cellH + 0.5)
          .transition().duration(200)
          .attr("fill", d => {
            if (d.n === 0) return "#f3f4f7";
            return metric === "count" ? colorCount(d.n) : colorAvg(d.sum / d.n);
          })
      );

      // simple legend (right-aligned)
      svg.selectAll("g.hm-legend").remove();
      const legend = svg.append("g").attr("class","hm-legend");
      const lx = width - m.right - 160, ly = m.top - 10;

      const gradId = "hmGrad" + Math.random().toString(36).slice(2);
      const defs = svg.append("defs");
      const grad = defs.append("linearGradient")
        .attr("id", gradId).attr("x1","0%").attr("y1","0%").attr("x2","100%").attr("y2","0%");
      const stops = d3.range(0, 1.01, 0.1).map(t => ({
        t,
        c: (metric === "count") ? colorCount(t * maxN) : colorAvg(3 + t * 2)
      }));
      grad.selectAll("stop")
        .data(stops).enter().append("stop")
        .attr("offset", d => (d.t*100)+"%")
        .attr("stop-color", d => d.c);

      legend.append("rect")
        .attr("x", lx).attr("y", ly)
        .attr("width", 140).attr("height", 10)
        .attr("fill", `url(#${gradId})`)
        .attr("stroke","#ccc");

      legend.append("text").attr("x", lx).attr("y", ly - 6)
        .text(metric === "count" ? "Count per bin" : "Avg rating").attr("font-size","12px").attr("fill","#444");

      legend.append("text").attr("x", lx).attr("y", ly + 24)
        .text(metric === "count" ? "0" : "3.0").attr("font-size","12px").attr("fill","#444");
      legend.append("text").attr("x", lx + 140).attr("y", ly + 24)
        .text(metric === "count" ? maxN : "5.0").attr("font-size","12px").attr("fill","#444");
    }

    catSel.on("change", render);
    skinSel.on("change", render);
    metricSel.on("change", render);
    binSlider.on("input", render);

    render();
  });
})();
</script>


</body>
</html>
