<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Skincare Scatterplot — Category + Skin Type Filters</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; background: #f6f7fb; margin: 24px; }
    h1 { text-align: center; margin: 0 0 8px; }
    .row { display: flex; gap: 16px; align-items: center; margin-bottom: 12px; }
    label { font-size: 14px; color: #333; }
    select { padding: 6px 10px; border-radius: 8px; border: 1px solid #ccc; background: #fff; }
    svg { background: #fff; border: 1px solid #ddd; border-radius: 8px; }
    .axis path, .axis line { stroke: #bbb; }
    .legend { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .legend .item { display: inline-flex; align-items: center; gap: 6px; font-size: 12px; color: #444; }
    .legend .swatch { width: 12px; height: 12px; border-radius: 2px; border: 1px solid #999; }
    .tooltip {
      position: fixed; pointer-events: none; z-index: 10;
      background: rgba(20,24,40,.95); color: #f2f4ff; padding: 8px 10px;
      border: 1px solid #404868; border-radius: 8px; font-size: 12px;
      transform: translate(10px, -10px); opacity: 0; transition: opacity .1s;
      max-width: 320px; line-height: 1.3;
    }
  </style>
</head>
<body>

      <!-- Page Title -->
  <h1>Project 3 checkpoint</h1>
  <p style="text-align:center; margin-top:4px; color:#555;">
Interactive visualizations exploring skincare data
</p>






  

    <h2 style="margin-bottom: 20px;">Price vs Rating</h2>
    <p style="margin-top:0; color:#666; font-size:14px;">
Explore how product prices and customer ratings vary across different categories and skin types.
</p>
    <div class="row">
    <label>Category:
      <select id="categorySelect"><option value="__all__">All</option></select>
    </label>
    <label>Skin Type:
      <select id="skinSelect">
        <option value="__all__">All</option>
        <option value="Dry">Dry</option>
        <option value="Normal">Normal</option>
        <option value="Oily">Oily</option>
        <option value="Combination">Combination</option>
        <option value="Sensitive">Sensitive</option>
      </select>
    </label>
  </div>

  <svg id="chart" width="860" height="540"></svg>
  <div class="legend" id="legend"></div>
  <div class="tooltip" id="tooltip"></div>

  <script>
    const width = 860, height = 540, margin = {top: 30, right: 20, bottom: 56, left: 64};
    const svg = d3.select("#chart").attr("width", width).attr("height", height);
    const g = svg.append("g");

    const xAxisG = g.append("g").attr("transform", `translate(0,${height - margin.bottom})`).attr("class","axis");
    const yAxisG = g.append("g").attr("transform", `translate(${margin.left},0)`).attr("class","axis");
    const pointsG = g.append("g").attr("class","points");

    const tooltip = d3.select("#tooltip");
    const categorySelect = d3.select("#categorySelect");
    const skinSelect = d3.select("#skinSelect");
    const legend = d3.select("#legend");

    const x = d3.scaleLinear().range([margin.left, width - margin.right]);
    const y = d3.scaleLinear().range([height - margin.bottom, margin.top]).domain([0,5]); // ratings 0–5
    const color = d3.scaleOrdinal(d3.schemeTableau10);

    const to01 = v => {
      if (v === undefined || v === null) return 0;
      const s = String(v).trim().toLowerCase();
      return (s === "1" || s === "true" || s === "yes" || s === "y") ? 1 : (+v === 1 ? 1 : 0);
    };

    d3.csv("data/cosmetic_p.csv").then(rows => {
      // parse
      const data = rows.map(d => ({
        brand: d.brand || d.Brand || "",
        name: d.name || d.Product || d.product_name || "",
        cat: d.Label || d.category || "Uncategorized",
        price: +d.price,
        rank: +d.rank,   // rating
        Dry: to01(d.Dry),
        Normal: to01(d.Normal),
        Oily: to01(d.Oily),
        Combination: to01(d.Combination),
        Sensitive: to01(d.Sensitive)
      })).filter(d => isFinite(d.price) && isFinite(d.rank));

      // scales
      x.domain(d3.extent(data, d => d.price)).nice();

      // axes
      const xAxis = d3.axisBottom(x).ticks(8).tickFormat(d3.format("$,.0f"));
      const yAxis = d3.axisLeft(y).ticks(6);
      xAxisG.call(xAxis)
            .append("text")
            .attr("x", width - margin.right)
            .attr("y", 40).attr("fill","#222")
            .attr("text-anchor","end").attr("font-weight","600")
            .text("Price ($)");
      yAxisG.call(yAxis)
            .append("text")
            .attr("x", 0).attr("y", margin.top - 12)
            .attr("fill","#222").attr("text-anchor","start").attr("font-weight","600")
            .text("Rating (0–5)");

      // categories (legend + dropdown)
      const cats = Array.from(new Set(data.map(d => d.cat))).sort();
      color.domain(cats);
      categorySelect.selectAll("option.cat")
        .data(cats)
        .join("option")
        .attr("class","cat")
        .attr("value", d => d)
        .text(d => d);
      legend.selectAll("span.item")
        .data(cats)
        .join("span")
        .attr("class","item")
        .html(d => `<span class="swatch" style="background:${color(d)}"></span> ${d}`);

      function render() {
        const selectedCat = categorySelect.node().value;
        const selectedSkin = skinSelect.node().value;

        let shown = selectedCat === "__all__" ? data : data.filter(d => d.cat === selectedCat);
        if (selectedSkin !== "__all__") {
          shown = shown.filter(d => d[selectedSkin] === 1);
        }

        const circles = pointsG.selectAll("circle").data(shown, d => d.brand + "|" + d.name + "|" + d.price);

        circles.exit()
          .transition().duration(150)
          .attr("r", 0).remove();

        circles.join(
          enter => enter.append("circle")
            .attr("cx", d => x(d.price))
            .attr("cy", d => y(d.rank))
            .attr("r", 0)
            .attr("fill", d => color(d.cat))
            .attr("opacity", 0.8)
            .on("pointerenter", (e, d) => {
              tooltip.html(`
                <div style="font-weight:600">${(d.brand || "").trim()} ${(d.name ? "— " + d.name : "")}</div>
                <div>${d.cat}</div>
                <div><b>Price:</b> ${d3.format("$,.2f")(d.price)} &nbsp; • &nbsp; <b>Rating:</b> ${d.rank.toFixed(2)}</div>
              `).style("opacity", 1);
            })
            .on("pointermove", (e) => {
              tooltip.style("left", (e.clientX + 12) + "px")
                     .style("top",  (e.clientY - 12) + "px");
            })
            .on("pointerleave", () => tooltip.style("opacity", 0))
            .transition().duration(300)
            .attr("r", 4.5),
          update => update
            .transition().duration(250)
            .attr("cx", d => x(d.price))
            .attr("cy", d => y(d.rank))
            .attr("fill", d => color(d.cat))
        );
      }

      categorySelect.on("change", render);
      skinSelect.on("change", render);
      render();
    });
  </script>








  <h2 style="margin-top:40px;">Ingredients vs Rating</h2>
  <p style="margin-top:0; color:#666; font-size:14px;">
Analyze which ingredients are most common in high-rated skincare products.
</p>
<div class="row">
  <label>Category:
    <select id="ingCategory"><option value="__all__">All</option></select>
  </label>
  <label>Min # of products that include ingredient:
    <input type="range" id="minCount" min="5" max="100" value="20" />
    <span id="minCountVal">20</span>
  </label>
</div>
<svg id="ingChart" width="860" height="540"></svg>
<div class="tooltip" id="tooltip2"></div>

<script>
(() => {
  const width = 860, height = 540, m = {top: 30, right: 20, bottom: 56, left: 200};
  const svg = d3.select("#ingChart").attr("width", width).attr("height", height);
  const g = svg.append("g");

  // axes groups
  const xAxisG = g.append("g").attr("transform", `translate(0,${height - m.bottom})`).attr("class","axis");
  const yAxisG = g.append("g").attr("transform", `translate(${m.left},0)`).attr("class","axis");

  const x = d3.scaleLinear().domain([0,5]).range([m.left, width - m.right]); // ratings 0–5
  const y = d3.scaleBand().padding(0.15).range([m.top, height - m.bottom]);

  const tooltip = d3.select("#tooltip2");
  const catSel = d3.select("#ingCategory");
  const minSlider = d3.select("#minCount");
  const minVal = d3.select("#minCountVal");

  // Basic ingredient parsing (kept independent from the first chart)
  function cleanToken(token){
    return token
      .replace(/\(.*?\)/g, "")     // remove ( ... )
      .replace(/\[.*?\]/g, "")     // remove [ ... ]
      .replace(/[^a-zA-Z\s\-]/g,"")// keep letters/spaces/hyphens
      .toLowerCase()
      .trim()
      .replace(/\s{2,}/g, " ");
  }
  function parseIngredients(s){
    if(!s) return [];
    return s.split(/,|;|\n/).map(cleanToken).filter(Boolean);
  }

  d3.csv("data/cosmetic_p.csv").then(rows => {
    const data = rows.map(d => ({
      brand: d.brand || d.Brand || "",
      name: d.name || d.Product || d.product_name || "",
      cat:  d.Label || d.category || "Uncategorized",
      rank: +d.rank,
      ingredients: parseIngredients(d.ingredients || d.Ingredients || d.INGREDIENTS || "")
    })).filter(d => isFinite(d.rank));

    // populate category select (independent)
    const cats = Array.from(new Set(data.map(d => d.cat))).sort();
    catSel.selectAll("option.cat")
      .data(cats).join("option")
      .attr("class","cat")
      .attr("value", d => d).text(d => d);

    function computeStats(){
      const selectedCat = catSel.node().value;
      const base = selectedCat === "__all__" ? data : data.filter(d => d.cat === selectedCat);

      // ingredient -> {n, sum, examples[]}
      const map = new Map();
      for(const prod of base){
        // Use a Set so a product only counts once per ingredient
        const uniq = new Set(prod.ingredients);
        for(const ing of uniq){
          if(!map.has(ing)) map.set(ing, {ing, n:0, sum:0, examples:[]});
          const rec = map.get(ing);
          rec.n += 1;
          rec.sum += prod.rank;
          if(rec.examples.length < 2) rec.examples.push(prod.brand || prod.name);
        }
      }

      let arr = Array.from(map.values());
      const minN = +minSlider.node().value;
      arr = arr.filter(d => d.n >= minN);
      arr.forEach(d => d.avg = d.sum / d.n);

      // Top 20 by average rating
      arr.sort((a,b) => d3.descending(a.avg, b.avg));
      return arr.slice(0, 20);
    }

    function render(){
      minVal.text(minSlider.node().value);
      const stats = computeStats();

      y.domain(stats.map(d => d.ing));

      xAxisG.call(d3.axisBottom(x).ticks(6));
      yAxisG.call(d3.axisLeft(y).tickSize(0))
            .selectAll("text").style("font-size","12px");

      // Bars
      const bars = g.selectAll("rect.bar").data(stats, d => d.ing);

      bars.exit()
        .transition().duration(200)
        .attr("width", 0)
        .remove();

      bars.join(
        enter => enter.append("rect")
          .attr("class","bar")
          .attr("x", x(0))
          .attr("y", d => y(d.ing))
          .attr("height", y.bandwidth())
          .attr("width", 0)
          .attr("fill", "#4c78a8")
          .on("pointerenter", (e, d) => {
            tooltip.html(
              `<b>${d.ing.replace(/\\b[a-z]/g,c=>c.toUpperCase())}</b><br>` +
              `Avg rating: ${d.avg.toFixed(2)}<br>` +
              `Products: ${d.n}<br>` +
              (d.examples.length ? `Examples: ${d.examples.join(", ")}` : "")
            ).style("opacity", 1);
          })
          .on("pointermove", (e) => {
            tooltip.style("left", (e.clientX + 12) + "px")
                   .style("top",  (e.clientY - 12) + "px");
          })
          .on("pointerleave", () => tooltip.style("opacity", 0))
          .transition().duration(300)
          .attr("width", d => x(d.avg) - x(0)),
        update => update
          .transition().duration(250)
          .attr("y", d => y(d.ing))
          .attr("height", y.bandwidth())
          .attr("width", d => x(d.avg) - x(0))
      );

      // Value labels
      const labels = g.selectAll("text.value").data(stats, d => d.ing);
      labels.exit().remove();
      labels.join(
        enter => enter.append("text")
          .attr("class","value")
          .attr("x", d => x(d.avg) + 6)
          .attr("y", d => y(d.ing) + y.bandwidth()/2 + 4)
          .attr("fill", "#333")
          .text(d => d.avg.toFixed(2)),
        update => update
          .transition().duration(250)
          .attr("x", d => x(d.avg) + 6)
          .attr("y", d => y(d.ing) + y.bandwidth()/2 + 4)
          .text(d => d.avg.toFixed(2))
      );
    }

    catSel.on("change", render);
    minSlider.on("input", render);
    render();
  });
})();
</script>




<!-- ===== Brand Ranking Chart (matched spacing) ===== -->
  <h2 style="margin-top:40px;">Top 15 Brands by Average Rating</h2>
  <p style="margin-top:0; color:#666; font-size:14px;">
Analyze which brands are most highly rated for skincare products.
</p>

<div class="row">
  <label>Category:
    <select id="brandCat"><option value="__all__">All</option></select>
  </label>
  <label>Skin Type:
    <select id="brandSkin">
      <option value="__all__">All</option>
      <option value="Dry">Dry</option>
      <option value="Normal">Normal</option>
      <option value="Oily">Oily</option>
      <option value="Combination">Combination</option>
      <option value="Sensitive">Sensitive</option>
    </select>
  </label>
</div>
<svg id="brandChart" width="860" height="540"></svg>
<div class="tooltip" id="tooltipBrand"></div>

<script>
(() => {
  // Match the other charts' dimensions, with a bit of extra right margin so labels don't clip
  const width = 860, height = 540, m = { top: 30, right: 60, bottom: 56, left: 180 };
  const svg = d3.select("#brandChart").attr("width", width).attr("height", height);
  const g = svg.append("g");

  const xAxisG = g.append("g")
    .attr("transform", `translate(0,${height - m.bottom})`)
    .attr("class","axis");
  const yAxisG = g.append("g")
    .attr("transform", `translate(${m.left},0)`)
    .attr("class","axis");

  const x = d3.scaleLinear().domain([0,5]).range([m.left, width - m.right]); // ratings 0–5
  const y = d3.scaleBand().padding(0.15).range([m.top, height - m.bottom]);

  const catSel  = d3.select("#brandCat");
  const skinSel = d3.select("#brandSkin");
  const tip     = d3.select("#tooltipBrand");
  const dollar  = d3.format("$,.2f");

  const to01 = v => {
    if (v == null) return 0;
    const s = String(v).trim().toLowerCase();
    return (s === "1" || s === "true" || s === "yes" || s === "y") ? 1 : (+v === 1 ? 1 : 0);
  };

  d3.csv("data/cosmetic_p.csv").then(rows => {
    const data = rows.map(d => ({
      brand: (d.brand || d.Brand || "").trim() || "Unknown",
      name:  d.name || d.Product || d.product_name || "",
      cat:   d.Label || d.category || "Uncategorized",
      price: +d.price,
      rank:  +d.rank,
      Dry: to01(d.Dry), Normal: to01(d.Normal), Oily: to01(d.Oily),
      Combination: to01(d.Combination), Sensitive: to01(d.Sensitive)
    })).filter(d => isFinite(d.rank));

    // Populate category dropdown (independent)
    const cats = Array.from(new Set(data.map(d => d.cat))).sort();
    catSel.selectAll("option.cat")
      .data(cats).join("option")
      .attr("class","cat").attr("value", d => d).text(d => d);

    function computeStats(){
      const c = catSel.node().value;
      const s = skinSel.node().value;

      let base = (c === "__all__") ? data : data.filter(d => d.cat === c);
      if (s !== "__all__") base = base.filter(d => d[s] === 1);

      const map = new Map();
      for (const p of base){
        if (!map.has(p.brand)) map.set(p.brand, { brand: p.brand, n:0, sumR:0, sumP:0 });
        const b = map.get(p.brand);
        b.n    += 1;
        b.sumR += p.rank;
        if (isFinite(p.price)) b.sumP += p.price;
      }

      let arr = Array.from(map.values());
      arr.forEach(d => {
        d.avgR = d.sumR / d.n;
        d.avgP = d.n ? d.sumP / d.n : 0;
      });

      // Sort by avg rating desc, then by product count desc
      arr.sort((a,b) => d3.descending(a.avgR, b.avgR) || d3.descending(a.n, b.n));
      return arr.slice(0, 15);
    }

    function render(){
      const stats = computeStats();

      y.domain(stats.map(d => d.brand));
      xAxisG.call(d3.axisBottom(x).ticks(6));
      yAxisG.call(d3.axisLeft(y).tickSize(0))
            .selectAll("text").style("font-size","12px");

      // Bars
      const bars = g.selectAll("rect.bar").data(stats, d => d.brand);

      bars.exit().transition().duration(200).attr("width", 0).remove();

      bars.join(
        enter => enter.append("rect")
          .attr("class","bar")
          .attr("x", x(0))
          .attr("y", d => y(d.brand))
          .attr("height", y.bandwidth())
          .attr("width", 0)
          .attr("fill", "#6aaed6")
          .on("pointerenter", (e, d) => {
            tip.html(
              `<b>${d.brand}</b><br>` +
              `Avg rating: ${d.avgR.toFixed(2)}<br>` +
              `Products: ${d.n}<br>` +
              `Avg price: ${dollar(d.avgP)}`
            ).style("opacity", 1);
          })
          .on("pointermove", (e) => {
            tip.style("left", (e.clientX + 12) + "px")
               .style("top",  (e.clientY - 12) + "px");
          })
          .on("pointerleave", () => tip.style("opacity", 0))
          .transition().duration(300)
          .attr("width", d => x(d.avgR) - x(0)),
        update => update
          .transition().duration(250)
          .attr("y", d => y(d.brand))
          .attr("height", y.bandwidth())
          .attr("width", d => x(d.avgR) - x(0))
      );

      // Value labels (shifted inside the right margin so they don't clip)
      const labels = g.selectAll("text.value").data(stats, d => d.brand);
      labels.exit().remove();
      labels.join(
        enter => enter.append("text")
          .attr("class","value")
          .attr("x", d => Math.min(x(d.avgR) + 6, width - m.right + 4))
          .attr("y", d => y(d.brand) + y.bandwidth()/2 + 4)
          .attr("fill", "#333")
          .text(d => d.avgR.toFixed(2)),
        update => update
          .transition().duration(250)
          .attr("x", d => Math.min(x(d.avgR) + 6, width - m.right + 4))
          .attr("y", d => y(d.brand) + y.bandwidth()/2 + 4)
          .text(d => d.avgR.toFixed(2))
      );
    }

    catSel.on("change", render);
    skinSel.on("change", render);
    render();
  });
})();
</script>






<!-- ===== Heatmap Explorer: Price × Rating ===== -->
  <h2 style="margin-top:40px;">Price x Rating Heatmap</h2>
  <p style="margin-top:0; color:#666; font-size:14px;">
Visualize the relationship between product price and customer rating.
</p>

<div class="row">
  <label>Category:
    <select id="hmCategory"><option value="__all__">All</option></select>
  </label>
  <label>Skin Type:
    <select id="hmSkin">
      <option value="__all__">All</option>
      <option value="Dry">Dry</option>
      <option value="Normal">Normal</option>
      <option value="Oily">Oily</option>
      <option value="Combination">Combination</option>
      <option value="Sensitive">Sensitive</option>
    </select>
  </label>
  <label>Metric:
    <select id="hmMetric">
      <option value="count">Count</option>
      <option value="avg">Avg Rating</option>
    </select>
  </label>
  <label>Bin size:
    <input id="hmBins" type="range" min="8" max="40" value="20">
    <span id="hmBinsVal">20</span>
  </label>
</div>

<svg id="heatmap" width="860" height="540"></svg>
<div class="tooltip" id="hmTooltip"></div>

<script>
(() => {
  const width = 860, height = 540, m = {top: 30, right: 20, bottom: 56, left: 64};
  const svg = d3.select("#heatmap").attr("width", width).attr("height", height);
  const g = svg.append("g");

  const xAxisG = g.append("g").attr("transform", `translate(0,${height - m.bottom})`).attr("class","axis");
  const yAxisG = g.append("g").attr("transform", `translate(${m.left},0)`).attr("class","axis");
  const cellsG = g.append("g").attr("class","cells");

  const x = d3.scaleLinear().range([m.left, width - m.right]);
  const y = d3.scaleLinear().range([height - m.bottom, m.top]).domain([0,5]); // rating 0–5

  const catSel  = d3.select("#hmCategory");
  const skinSel = d3.select("#hmSkin");
  const metricSel = d3.select("#hmMetric");
  const binSlider = d3.select("#hmBins");
  const binVal = d3.select("#hmBinsVal");
  const tip = d3.select("#hmTooltip");

  const to01 = v => {
    if (v == null) return 0;
    const s = String(v).trim().toLowerCase();
    return (s === "1" || s === "true" || s === "yes" || s === "y") ? 1 : (+v === 1 ? 1 : 0);
  };

  d3.csv("data/cosmetic_p.csv").then(rows => {
    const data = rows.map(d => ({
      cat:   d.Label || d.category || "Uncategorized",
      price: +d.price,
      rank:  +d.rank,
      Dry: to01(d.Dry), Normal: to01(d.Normal), Oily: to01(d.Oily),
      Combination: to01(d.Combination), Sensitive: to01(d.Sensitive)
    })).filter(d => isFinite(d.price) && isFinite(d.rank));

    // scales
    x.domain(d3.extent(data, d => d.price)).nice();

    // axes with labels
    xAxisG.call(d3.axisBottom(x).ticks(8).tickFormat(d3.format("$,.0f")))
      .append("text")
      .attr("x", width - m.right)
      .attr("y", 40).attr("fill","#222").attr("text-anchor","end").attr("font-weight","600")
      .text("Price ($)");
    yAxisG.call(d3.axisLeft(y).ticks(6))
      .append("text")
      .attr("x", 0).attr("y", m.top - 12)
      .attr("fill","#222").attr("text-anchor","start").attr("font-weight","600")
      .text("Rating (0–5)");

    // categories
    const cats = Array.from(new Set(data.map(d => d.cat))).sort();
    catSel.selectAll("option.cat")
      .data(cats).join("option")
      .attr("class","cat").attr("value", d => d).text(d => d);

    // color scales for two metrics
    const colorCount = d3.scaleSequential().interpolator(d3.interpolateBlues); // darker = more products
    const colorAvg   = d3.scaleSequential().domain([3, 5]).interpolator(d3.interpolateYlGn); // greener = higher avg rating

    function binData() {
      const binsX = +binSlider.node().value; // number of bins across X
      const binsY = Math.round(binsX * 0.5); // keep rectangular-ish cells

      const xThresh = d3.range(binsX + 1).map(t => x.invert(m.left + t * ( (width - m.left - m.right) / binsX )));
      const yThresh = d3.range(binsY + 1).map(t => y.invert( (height - m.bottom) - t * ( (height - m.bottom - m.top) / binsY ) ));

      const selCat  = catSel.node().value;
      const selSkin = skinSel.node().value;

      let base = (selCat === "__all__") ? data : data.filter(d => d.cat === selCat);
      if (selSkin !== "__all__") base = base.filter(d => d[selSkin] === 1);

      // initialize empty grid
      const grid = [];
      for (let j = 0; j < binsY; j++) {
        for (let i = 0; i < binsX; i++) {
          grid.push({i, j, n:0, sum:0});
        }
      }

      // put each product into a cell
      const xMin = x.domain()[0], xMax = x.domain()[1];
      const yMin = 0, yMax = 5;
      const ix = v => Math.min(binsX - 1, Math.max(0, Math.floor( (v - xMin) / (xMax - xMin) * binsX )));
      const iy = v => Math.min(binsY - 1, Math.max(0, Math.floor( (v - yMin) / (yMax - yMin) * binsY )));

      for (const p of base) {
        const ci = ix(p.price);
        const cj = iy(p.rank);
        const c  = grid[cj * binsX + ci];
        c.n += 1;
        c.sum += p.rank;
      }

      // domains for color
      const maxN = d3.max(grid, d => d.n) || 1;
      colorCount.domain([0, maxN]);      // automatically adapts to density
      colorAvg.domain([3, 5]);           // fixed, highlights high-rating pockets

      return { grid, binsX, binsY, maxN };
    }

    function render() {
      binVal.text(binSlider.node().value);
      const metric = metricSel.node().value; // 'count' | 'avg'
      const { grid, binsX, binsY, maxN } = binData();

      const cellW = (width - m.left - m.right) / binsX;
      const cellH = (height - m.bottom - m.top) / binsY;

      const rects = cellsG.selectAll("rect.cell").data(grid, d => d.i + "-" + d.j);

      rects.exit().remove();

      rects.join(
        enter => enter.append("rect")
          .attr("class", "cell")
          .attr("x", d => m.left + d.i * cellW)
          .attr("y", d => m.top + (binsY - 1 - d.j) * cellH) // invert y so higher rating is higher
          .attr("width", cellW + 0.5)
          .attr("height", cellH + 0.5)
          .attr("fill", d => {
            if (d.n === 0) return "#f3f4f7";
            return metric === "count" ? colorCount(d.n) : colorAvg(d.sum / d.n);
          })
          .on("pointerenter", (e, d) => {
            if (d.n === 0) return;
            const avg = (d.sum / d.n).toFixed(2);
            tip.html(metric === "count"
              ? `<b>${d.n}</b> products in this bin`
              : `Avg rating: <b>${avg}</b><br>Products: ${d.n}`
            ).style("opacity", 1);
          })
          .on("pointermove", (e) => {
            tip.style("left", (e.clientX + 12) + "px")
               .style("top",  (e.clientY - 12) + "px");
          })
          .on("pointerleave", () => tip.style("opacity", 0)),
        update => update
          .attr("x", d => m.left + d.i * cellW)
          .attr("y", d => m.top + (binsY - 1 - d.j) * cellH)
          .attr("width", cellW + 0.5)
          .attr("height", cellH + 0.5)
          .transition().duration(200)
          .attr("fill", d => {
            if (d.n === 0) return "#f3f4f7";
            return metric === "count" ? colorCount(d.n) : colorAvg(d.sum / d.n);
          })
      );

      // simple legend (right-aligned)
      svg.selectAll("g.hm-legend").remove();
      const legend = svg.append("g").attr("class","hm-legend");
      const lx = width - m.right - 160, ly = m.top - 10;

      const gradId = "hmGrad" + Math.random().toString(36).slice(2);
      const defs = svg.append("defs");
      const grad = defs.append("linearGradient")
        .attr("id", gradId).attr("x1","0%").attr("y1","0%").attr("x2","100%").attr("y2","0%");
      const stops = d3.range(0, 1.01, 0.1).map(t => ({
        t,
        c: (metric === "count") ? colorCount(t * maxN) : colorAvg(3 + t * 2)
      }));
      grad.selectAll("stop")
        .data(stops).enter().append("stop")
        .attr("offset", d => (d.t*100)+"%")
        .attr("stop-color", d => d.c);

      legend.append("rect")
        .attr("x", lx).attr("y", ly)
        .attr("width", 140).attr("height", 10)
        .attr("fill", `url(#${gradId})`)
        .attr("stroke","#ccc");

      legend.append("text").attr("x", lx).attr("y", ly - 6)
        .text(metric === "count" ? "Count per bin" : "Avg rating").attr("font-size","12px").attr("fill","#444");

      legend.append("text").attr("x", lx).attr("y", ly + 24)
        .text(metric === "count" ? "0" : "3.0").attr("font-size","12px").attr("fill","#444");
      legend.append("text").attr("x", lx + 140).attr("y", ly + 24)
        .text(metric === "count" ? maxN : "5.0").attr("font-size","12px").attr("fill","#444");
    }

    catSel.on("change", render);
    skinSel.on("change", render);
    metricSel.on("change", render);
    binSlider.on("input", render);

    render();
  });
})();
</script>




</body>
</html>
